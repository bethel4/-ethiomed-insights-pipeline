[
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "psycopg2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "psycopg2",
        "description": "psycopg2",
        "detail": "psycopg2",
        "documentation": {}
    },
    {
        "label": "RealDictCursor",
        "importPath": "psycopg2.extras",
        "description": "psycopg2.extras",
        "isExtraImport": true,
        "detail": "psycopg2.extras",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "YOLO",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "TelegramClient",
        "importPath": "telethon.sync",
        "description": "telethon.sync",
        "isExtraImport": true,
        "detail": "telethon.sync",
        "documentation": {}
    },
    {
        "label": "TelegramClient",
        "importPath": "telethon.sync",
        "description": "telethon.sync",
        "isExtraImport": true,
        "detail": "telethon.sync",
        "documentation": {}
    },
    {
        "label": "get_top_products",
        "kind": 2,
        "importPath": "api.crud",
        "description": "api.crud",
        "peekOfCode": "def get_top_products(limit: int = 10) -> List[ProductAnalytics]:\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    query = \"\"\"\n    WITH product_mentions AS (\n        SELECT \n            CASE \n                WHEN text ILIKE '%paracetamol%' THEN 'Paracetamol'\n                WHEN text ILIKE '%vitamin%' THEN 'Vitamin'\n                WHEN text ILIKE '%iron%' THEN 'Iron'",
        "detail": "api.crud",
        "documentation": {}
    },
    {
        "label": "get_channel_activity",
        "kind": 2,
        "importPath": "api.crud",
        "description": "api.crud",
        "peekOfCode": "def get_channel_activity(channel_name: str) -> ChannelActivity:\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    query = \"\"\"\n    SELECT \n        %s as channel_name,\n        COUNT(*) as message_count,\n        COUNT(CASE WHEN has_media THEN 1 END) as image_count,\n        MAX(date::date) as last_activity\n    FROM raw_telegram_messages",
        "detail": "api.crud",
        "documentation": {}
    },
    {
        "label": "search_messages",
        "kind": 2,
        "importPath": "api.crud",
        "description": "api.crud",
        "peekOfCode": "def search_messages(query: str, limit: int = 10) -> List[MessageSearch]:\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    search_query = \"\"\"\n    SELECT \n        m.id as message_id,\n        m.text,\n        'lobelia4cosmetics' as channel,\n        m.date::date as date,\n        m.has_media,",
        "detail": "api.crud",
        "documentation": {}
    },
    {
        "label": "get_db_connection",
        "kind": 2,
        "importPath": "api.database",
        "description": "api.database",
        "peekOfCode": "def get_db_connection():\n    return psycopg2.connect(\n        host=os.getenv(\"POSTGRES_HOST\"),\n        dbname=os.getenv(\"POSTGRES_DB\"),\n        user=os.getenv(\"POSTGRES_USER\"),\n        password=os.getenv(\"POSTGRES_PASSWORD\"),\n        port=os.getenv(\"POSTGRES_PORT\"),\n        cursor_factory=RealDictCursor\n    )",
        "detail": "api.database",
        "documentation": {}
    },
    {
        "label": "read_root",
        "kind": 2,
        "importPath": "api.main",
        "description": "api.main",
        "peekOfCode": "def read_root():\n    return {\"message\": \"Ethiomed Insights API - Welcome!\"}\n@app.get(\"/api/reports/top-products\", response_model=TopProductsResponse)\ndef get_top_products(limit: int = 10):\n    \"\"\"\n    Get the most frequently mentioned medical products across all channels.\n    \"\"\"\n    try:\n        products = crud.get_top_products(limit)\n        return TopProductsResponse(",
        "detail": "api.main",
        "documentation": {}
    },
    {
        "label": "get_top_products",
        "kind": 2,
        "importPath": "api.main",
        "description": "api.main",
        "peekOfCode": "def get_top_products(limit: int = 10):\n    \"\"\"\n    Get the most frequently mentioned medical products across all channels.\n    \"\"\"\n    try:\n        products = crud.get_top_products(limit)\n        return TopProductsResponse(\n            products=products,\n            total_count=len(products)\n        )",
        "detail": "api.main",
        "documentation": {}
    },
    {
        "label": "get_channel_activity",
        "kind": 2,
        "importPath": "api.main",
        "description": "api.main",
        "peekOfCode": "def get_channel_activity(channel_name: str):\n    \"\"\"\n    Get posting activity for a specific channel.\n    \"\"\"\n    try:\n        return crud.get_channel_activity(channel_name)\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n@app.get(\"/api/search/messages\", response_model=List[MessageSearch])\ndef search_messages(query: str, limit: int = 10):",
        "detail": "api.main",
        "documentation": {}
    },
    {
        "label": "search_messages",
        "kind": 2,
        "importPath": "api.main",
        "description": "api.main",
        "peekOfCode": "def search_messages(query: str, limit: int = 10):\n    \"\"\"\n    Search for messages containing a specific keyword.\n    \"\"\"\n    try:\n        return crud.search_messages(query, limit)\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n@app.get(\"/api/health\")\ndef health_check():",
        "detail": "api.main",
        "documentation": {}
    },
    {
        "label": "health_check",
        "kind": 2,
        "importPath": "api.main",
        "description": "api.main",
        "peekOfCode": "def health_check():\n    \"\"\"\n    Health check endpoint.\n    \"\"\"\n    return {\"status\": \"healthy\", \"service\": \"Ethiomed Insights API\"}\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)",
        "detail": "api.main",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "api.main",
        "description": "api.main",
        "peekOfCode": "app = FastAPI(\n    title=\"Ethiomed Insights API\",\n    description=\"Analytical API for Ethiopian medical business data from Telegram\",\n    version=\"1.0.0\"\n)\n@app.get(\"/\")\ndef read_root():\n    return {\"message\": \"Ethiomed Insights API - Welcome!\"}\n@app.get(\"/api/reports/top-products\", response_model=TopProductsResponse)\ndef get_top_products(limit: int = 10):",
        "detail": "api.main",
        "documentation": {}
    },
    {
        "label": "ProductAnalytics",
        "kind": 6,
        "importPath": "api.schemas",
        "description": "api.schemas",
        "peekOfCode": "class ProductAnalytics(BaseModel):\n    product_name: str\n    mention_count: int\n    avg_price: Optional[float]\n    channels: List[str]\nclass ChannelActivity(BaseModel):\n    channel_name: str\n    message_count: int\n    image_count: int\n    last_activity: date",
        "detail": "api.schemas",
        "documentation": {}
    },
    {
        "label": "ChannelActivity",
        "kind": 6,
        "importPath": "api.schemas",
        "description": "api.schemas",
        "peekOfCode": "class ChannelActivity(BaseModel):\n    channel_name: str\n    message_count: int\n    image_count: int\n    last_activity: date\nclass MessageSearch(BaseModel):\n    message_id: int\n    text: str\n    channel: str\n    date: date",
        "detail": "api.schemas",
        "documentation": {}
    },
    {
        "label": "MessageSearch",
        "kind": 6,
        "importPath": "api.schemas",
        "description": "api.schemas",
        "peekOfCode": "class MessageSearch(BaseModel):\n    message_id: int\n    text: str\n    channel: str\n    date: date\n    has_media: bool\n    detected_objects: List[str]\nclass TopProductsResponse(BaseModel):\n    products: List[ProductAnalytics]\n    total_count: int",
        "detail": "api.schemas",
        "documentation": {}
    },
    {
        "label": "TopProductsResponse",
        "kind": 6,
        "importPath": "api.schemas",
        "description": "api.schemas",
        "peekOfCode": "class TopProductsResponse(BaseModel):\n    products: List[ProductAnalytics]\n    total_count: int\nclass ChannelActivityResponse(BaseModel):\n    activities: List[ChannelActivity]\n    total_channels: int",
        "detail": "api.schemas",
        "documentation": {}
    },
    {
        "label": "ChannelActivityResponse",
        "kind": 6,
        "importPath": "api.schemas",
        "description": "api.schemas",
        "peekOfCode": "class ChannelActivityResponse(BaseModel):\n    activities: List[ChannelActivity]\n    total_channels: int",
        "detail": "api.schemas",
        "documentation": {}
    },
    {
        "label": "conn",
        "kind": 5,
        "importPath": "etl.load_to_postgres",
        "description": "etl.load_to_postgres",
        "peekOfCode": "conn = psycopg2.connect(\n    host=os.getenv(\"POSTGRES_HOST\"),\n    dbname=os.getenv(\"POSTGRES_DB\"),\n    user=os.getenv(\"POSTGRES_USER\"),\n    password=os.getenv(\"POSTGRES_PASSWORD\"),\n    port=os.getenv(\"POSTGRES_PORT\")\n)\ncursor = conn.cursor()\ncursor.execute(\"\"\"\nCREATE TABLE IF NOT EXISTS raw_telegram_messages (",
        "detail": "etl.load_to_postgres",
        "documentation": {}
    },
    {
        "label": "cursor",
        "kind": 5,
        "importPath": "etl.load_to_postgres",
        "description": "etl.load_to_postgres",
        "peekOfCode": "cursor = conn.cursor()\ncursor.execute(\"\"\"\nCREATE TABLE IF NOT EXISTS raw_telegram_messages (\n    id BIGINT PRIMARY KEY,\n    text TEXT,\n    date TIMESTAMP,\n    has_media BOOLEAN,\n    media_type TEXT\n);\n\"\"\")",
        "detail": "etl.load_to_postgres",
        "documentation": {}
    },
    {
        "label": "base_dir",
        "kind": 5,
        "importPath": "etl.load_to_postgres",
        "description": "etl.load_to_postgres",
        "peekOfCode": "base_dir = \"data/raw/telegram_messages\"\nfor date_folder in os.listdir(base_dir):\n    full_path = os.path.join(base_dir, date_folder)\n    for file in os.listdir(full_path):\n        with open(os.path.join(full_path, file)) as f:\n            messages = json.load(f)\n            for msg in messages:\n                try:\n                    cursor.execute(\"\"\"\n                        INSERT INTO raw_telegram_messages (id, text, date, has_media, media_type)",
        "detail": "etl.load_to_postgres",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "etl.run_yolo_detection",
        "description": "etl.run_yolo_detection",
        "peekOfCode": "model = YOLO('yolov8n.pt')  # Use nano model for speed\n# Connect to database\nconn = psycopg2.connect(\n    host=os.getenv(\"POSTGRES_HOST\"),\n    dbname=os.getenv(\"POSTGRES_DB\"),\n    user=os.getenv(\"POSTGRES_USER\"),\n    password=os.getenv(\"POSTGRES_PASSWORD\"),\n    port=os.getenv(\"POSTGRES_PORT\")\n)\ncursor = conn.cursor()",
        "detail": "etl.run_yolo_detection",
        "documentation": {}
    },
    {
        "label": "conn",
        "kind": 5,
        "importPath": "etl.run_yolo_detection",
        "description": "etl.run_yolo_detection",
        "peekOfCode": "conn = psycopg2.connect(\n    host=os.getenv(\"POSTGRES_HOST\"),\n    dbname=os.getenv(\"POSTGRES_DB\"),\n    user=os.getenv(\"POSTGRES_USER\"),\n    password=os.getenv(\"POSTGRES_PASSWORD\"),\n    port=os.getenv(\"POSTGRES_PORT\")\n)\ncursor = conn.cursor()\n# Create table for detection results\ncursor.execute(\"\"\"",
        "detail": "etl.run_yolo_detection",
        "documentation": {}
    },
    {
        "label": "cursor",
        "kind": 5,
        "importPath": "etl.run_yolo_detection",
        "description": "etl.run_yolo_detection",
        "peekOfCode": "cursor = conn.cursor()\n# Create table for detection results\ncursor.execute(\"\"\"\nCREATE TABLE IF NOT EXISTS fct_image_detections (\n    id SERIAL PRIMARY KEY,\n    message_id BIGINT REFERENCES raw_telegram_messages(id),\n    detected_object_class TEXT,\n    confidence_score FLOAT,\n    bbox_x1 FLOAT,\n    bbox_y1 FLOAT,",
        "detail": "etl.run_yolo_detection",
        "documentation": {}
    },
    {
        "label": "messages_with_images",
        "kind": 5,
        "importPath": "etl.run_yolo_detection",
        "description": "etl.run_yolo_detection",
        "peekOfCode": "messages_with_images = cursor.fetchall()\nfor message_id, image_path in messages_with_images:\n    if os.path.exists(image_path):\n        try:\n            # Run YOLO detection\n            results = model(image_path)\n            for result in results:\n                boxes = result.boxes\n                if boxes is not None:\n                    for box in boxes:",
        "detail": "etl.run_yolo_detection",
        "documentation": {}
    },
    {
        "label": "api_id",
        "kind": 5,
        "importPath": "etl.scrape_telegram",
        "description": "etl.scrape_telegram",
        "peekOfCode": "api_id = int(os.getenv(\"TELEGRAM_API_ID\"))\napi_hash = os.getenv(\"TELEGRAM_API_HASH\")\nchannels = [\n    \"https://t.me/lobelia4cosmetics\",\n    \"https://t.me/tikvahpharma\",\n    \"https://t.me/lobelia4cosmetics\"  # Add more if needed\n]\nclient = TelegramClient(\"session\", api_id, api_hash)\nclient.start()\ntotal_messages = 0",
        "detail": "etl.scrape_telegram",
        "documentation": {}
    },
    {
        "label": "api_hash",
        "kind": 5,
        "importPath": "etl.scrape_telegram",
        "description": "etl.scrape_telegram",
        "peekOfCode": "api_hash = os.getenv(\"TELEGRAM_API_HASH\")\nchannels = [\n    \"https://t.me/lobelia4cosmetics\",\n    \"https://t.me/tikvahpharma\",\n    \"https://t.me/lobelia4cosmetics\"  # Add more if needed\n]\nclient = TelegramClient(\"session\", api_id, api_hash)\nclient.start()\ntotal_messages = 0\ntotal_images = 0",
        "detail": "etl.scrape_telegram",
        "documentation": {}
    },
    {
        "label": "channels",
        "kind": 5,
        "importPath": "etl.scrape_telegram",
        "description": "etl.scrape_telegram",
        "peekOfCode": "channels = [\n    \"https://t.me/lobelia4cosmetics\",\n    \"https://t.me/tikvahpharma\",\n    \"https://t.me/lobelia4cosmetics\"  # Add more if needed\n]\nclient = TelegramClient(\"session\", api_id, api_hash)\nclient.start()\ntotal_messages = 0\ntotal_images = 0\ntotal_errors = 0",
        "detail": "etl.scrape_telegram",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "etl.scrape_telegram",
        "description": "etl.scrape_telegram",
        "peekOfCode": "client = TelegramClient(\"session\", api_id, api_hash)\nclient.start()\ntotal_messages = 0\ntotal_images = 0\ntotal_errors = 0\nfor channel in channels:\n    try:\n        logging.info(f\"Scraping channel: {channel}\")\n        messages_data = []\n        today = datetime.today().strftime('%Y-%m-%d')",
        "detail": "etl.scrape_telegram",
        "documentation": {}
    },
    {
        "label": "total_messages",
        "kind": 5,
        "importPath": "etl.scrape_telegram",
        "description": "etl.scrape_telegram",
        "peekOfCode": "total_messages = 0\ntotal_images = 0\ntotal_errors = 0\nfor channel in channels:\n    try:\n        logging.info(f\"Scraping channel: {channel}\")\n        messages_data = []\n        today = datetime.today().strftime('%Y-%m-%d')\n        name = channel.split(\"/\")[-1]\n        for message in client.iter_messages(channel, limit=100):",
        "detail": "etl.scrape_telegram",
        "documentation": {}
    },
    {
        "label": "total_images",
        "kind": 5,
        "importPath": "etl.scrape_telegram",
        "description": "etl.scrape_telegram",
        "peekOfCode": "total_images = 0\ntotal_errors = 0\nfor channel in channels:\n    try:\n        logging.info(f\"Scraping channel: {channel}\")\n        messages_data = []\n        today = datetime.today().strftime('%Y-%m-%d')\n        name = channel.split(\"/\")[-1]\n        for message in client.iter_messages(channel, limit=100):\n            msg_dict = {",
        "detail": "etl.scrape_telegram",
        "documentation": {}
    },
    {
        "label": "total_errors",
        "kind": 5,
        "importPath": "etl.scrape_telegram",
        "description": "etl.scrape_telegram",
        "peekOfCode": "total_errors = 0\nfor channel in channels:\n    try:\n        logging.info(f\"Scraping channel: {channel}\")\n        messages_data = []\n        today = datetime.today().strftime('%Y-%m-%d')\n        name = channel.split(\"/\")[-1]\n        for message in client.iter_messages(channel, limit=100):\n            msg_dict = {\n                \"id\": message.id,",
        "detail": "etl.scrape_telegram",
        "documentation": {}
    },
    {
        "label": "api_id",
        "kind": 5,
        "importPath": "etl.test_telegram_connection",
        "description": "etl.test_telegram_connection",
        "peekOfCode": "api_id = int(os.getenv(\"TELEGRAM_API_ID\"))\napi_hash = os.getenv(\"TELEGRAM_API_HASH\")\nclient = TelegramClient(\"session\", api_id, api_hash)\nclient.start()",
        "detail": "etl.test_telegram_connection",
        "documentation": {}
    },
    {
        "label": "api_hash",
        "kind": 5,
        "importPath": "etl.test_telegram_connection",
        "description": "etl.test_telegram_connection",
        "peekOfCode": "api_hash = os.getenv(\"TELEGRAM_API_HASH\")\nclient = TelegramClient(\"session\", api_id, api_hash)\nclient.start()",
        "detail": "etl.test_telegram_connection",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "etl.test_telegram_connection",
        "description": "etl.test_telegram_connection",
        "peekOfCode": "client = TelegramClient(\"session\", api_id, api_hash)\nclient.start()",
        "detail": "etl.test_telegram_connection",
        "documentation": {}
    }
]